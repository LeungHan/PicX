// Package test
// @author: LeungHan
// @date: 2022/12/4
// @desc:
// TODO
package main

import "fmt"

type FuzzyKmp struct {
}

var punctuationSet = map[string]bool{
	"？": true,
	"，": true,
	"。": true,
	"；": true,
	"：": true,
	"！": true,
	"、": true,
	"“": true,
	"”": true,
	"‘": true,
	"’": true,
}

func (k *FuzzyKmp) match(s, p string, errCount, offset int) string {
	if len(s) == 0 || len(p) == 0 || len(s) < len(p) {
		return ""
	}
	sRune := k.toRuneArray(s)
	pRune := k.toRuneArray(p)
	start, end := k.getIndexOf(sRune, pRune, errCount, offset)
	return string(sRune[start:end])
}

// 	str1 := "a  b a b a b a z c a"
//	str2 := "a  b a b a b c a"
//  next := "-1 0 0 1 2 3 4 0"
//str1 := "学而时习之学而时习之学而时习只"
//str2 := "学,而时习之学而时习只"
func (k *FuzzyKmp) getIndexOf(sRune, pRune []rune, maxErrCount, maxOffset int) (int, int) {
	if len(sRune) == 0 || len(pRune) == 0 || len(sRune) < len(pRune) {
		return -1, -1
	}
	var p1, p2 int
	var flag bool
	var startIndex int
	next := k.getNextArray(pRune) // O(M)
	for p1 < len(sRune) && p2 < len(pRune) {
		fmt.Println(string(sRune[p1]))
		fmt.Println(string(pRune[p2]))
		if sRune[p1] == pRune[p2] {
			if !flag {
				flag = true
				startIndex = p1
			}
			p1++
			p2++
		} else if next[p2] == -1 {
			// pStart 来到了0位置
			p1++
		} else {
			if isPunctuation, nP1, nP2 := k.isPunctuation(sRune, pRune, p1, p2); isPunctuation {
				p1 = nP1
				p2 = nP2
				continue
			}

			// 不相等的情况
			if isErrChar, nP1, nP2 := k.isErrChar(sRune, pRune, p1, p2, maxErrCount); isErrChar {
				// 如果是错字，且在错误范围内
				// nP1和nP2已经判等，跳过到下一个
				p1 = nP1 + 1
				p2 = nP2 + 1
				continue
			}

			if isRightOffsetChar, nP1, nP2 := k.isRightOffsetChar(sRune, pRune, p1, p2, maxOffset); isRightOffsetChar {
				// 如果是多字，且在错误范围内
				p1 = nP1 + 1
				p2 = nP2 + 1
				continue
			}

			if isLeftOffsetChar, nP1, nP2 := k.isLeftOffsetChar(sRune, pRune, p1, p2, maxOffset); isLeftOffsetChar {
				// 如果是少字，且在错误范围内
				p1 = nP1 + 1
				p2 = nP2 + 1
				continue
			}
			// 如果都不是，进行回退
			p2 = next[p2]
			if p2 == 0 {
				flag = false
			}
		}
	}

	if p2 < len(pRune) {
		return -1, -1
	}
	return startIndex, p1
}

// getNextArray 前一部分能完全匹配
func (k *FuzzyKmp) getNextArray(arr []rune) []int {
	if len(arr) == 1 {
		return []int{-1}
	}
	next := make([]int, len(arr))
	next[0] = -1
	next[1] = 0
	for i, cn := 2, 0; i < len(next); {
		if arr[i-1] == arr[cn] {
			cn++
			next[i] = cn
			i++
		} else if cn > 0 {
			cn = next[cn]
		} else {
			next[i] = 0
			i++
		}
	}
	return next
}

func (k *FuzzyKmp) isPunctuation(arr1, arr2 []rune, p1, p2 int) (bool, int, int) {
	if p1 < len(arr1) && p2 < len(arr2) && (punctuationSet[string(arr1[p1])] || punctuationSet[string(arr2[p2])]) {
		if punctuationSet[string(arr1[p1])] {
			p1++
		}
		if punctuationSet[string(arr2[p2])] {
			p2++
		}

		return true, p1, p2
	}
	return false, -1, -1
}

func (k *FuzzyKmp) isErrChar(arr1, arr2 []rune, p1, p2 int, maxErrCount int) (bool, int, int) {
	if maxErrCount <= 0 {
		return false, -1, -1
	}
	var curErrCount int
	for curErrCount < maxErrCount {
		p2++
		if p2 >= len(arr2) {
			return true, p1, p2
		}
		p1++
		if p1 >= len(arr1) {
			return false, -1, -1
		}

		if isPunctuation, nP1, nP2 := k.isPunctuation(arr1, arr2, p1, p2); isPunctuation {
			// 如果遇到了标点，进行跳过
			p1 = nP1
			p2 = nP2
			continue
		}
		if arr1[p1] == arr2[p2] {
			return true, p1, p2
		}
		curErrCount++
	}
	return false, -1, -1
}

func (k *FuzzyKmp) isRightOffsetChar(arr1, arr2 []rune, p1, p2 int, maxOffset int) (bool, int, int) {
	if maxOffset <= 0 {
		return false, -1, -1
	}
	var curRightOffset int
	for curRightOffset < maxOffset {
		if p2 >= len(arr2) {
			return true, p1, p2
		}
		p1++
		if p1 >= len(arr1) {
			return false, -1, -1
		}
		if isPunctuation, nP1, nP2 := k.isPunctuation(arr1, arr2, p1, p2); isPunctuation {
			// 如果遇到了标点，进行跳过
			p1 = nP1
			p2 = nP2
			continue
		}
		if arr1[p1] == arr2[p2] {
			return true, p1, p2
		}
		curRightOffset++
	}
	return false, -1, -1
}

func (k *FuzzyKmp) isLeftOffsetChar(arr1, arr2 []rune, p1, p2 int, maxOffset int) (bool, int, int) {
	if maxOffset <= 0 {
		return false, -1, -1
	}
	var curLeftOffset int
	for curLeftOffset < maxOffset {
		p2++
		if p2 >= len(arr2) {
			return true, p1, p2
		}
		if p1 >= len(arr1) {
			return false, -1, -1
		}
		if isPunctuation, nP1, nP2 := k.isPunctuation(arr1, arr2, p1, p2); isPunctuation {
			// 如果遇到了标点，进行跳过
			p1 = nP1
			p2 = nP2
			continue
		}
		if arr1[p1] == arr2[p2] {
			return true, p1, p2
		}
		curLeftOffset++
	}
	return false, -1, -1
}

func (k *FuzzyKmp) toRuneArray(str string) []rune {
	return []rune(str)
}

func main() {
	str1 := "学，而。时；习。之学而时习之学而时习只"
	str2 := "学，而时习之学而时习只"

	//str1 := "箸車中。既至，荀使叔慈應門，慈明行酒，学，学，学，而而而。有！时之，不；亦：哀乎？之淑有八子：儉鯤靖燾汪爽肅敷。淑居西豪里，縣令苑康曰：‘昔高陽氏有才子八人。’遂署其里爲高陽里。時人號曰八龍。”文若亦小，坐箸前。于時太史奏：“真人東行。”檀道鸞續晉陽秋曰：“陳仲弓從諸子姪造荀父子，于時德星聚，太史奏：‘五百里賢人聚。’”奏：‘五百里賢人聚。’”客有問陳季方：海内先賢傳曰：“陳諶字季方，寔少子也。才識博達。司空掾公車徵，不就。”“足下家君太丘，有何功德而荷天下重名？”季方曰：“吾家君譬如桂樹生泰山之阿，上有萬仞之高，下有不測之深；上爲甘露所霑，下爲淵泉所潤。當斯之時，桂樹焉知泰山之高，淵泉之深，不知有功德與無也！”德與無也！”陳元方子長文有英才，魏書曰：‘陳羣字長文，祖寔，嘗謂宗人曰：‘此兒必興吾宗。’及"
	//str2 := "学学学而而而时习之不亦乐乎"

	kmp := &FuzzyKmp{}
	res := kmp.match(str1, str2, 1, 1)
	fmt.Print(res)
}
